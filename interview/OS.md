关于一些知识
题目：
1、给定一个字符串，只能添加字母，最少的方法使它变成回文
可以dp[][]双指针，从两边往里面缩
2、给二叉树，找路径和等于target的数量，先做一遍记录数量再根据前缀和做。

#### static初始化

#### I/O多路复用

#### 线程安全

#### B+树、B树、红黑树

#### MySQL slect的运行过程

#### left join等

#### 后台运行
命令加上 &，可以后台运行，但控制台关掉，就会停止。

重定向 command > out.file 2>&1 &  标准输出和错误输出重定向到out.file文件中

nohup command &， 后台不挂起

2>&1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&， 是让该命令在后台执行。

试想2>1代表什么，2与>结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2>&1，&与1结合就代表标准输出了，就变成错误重定向到标准输出.


#### 守护进程、僵尸进程、孤儿进程

守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。

创建守护进程，setsid。该进程变成新会话的会话首进程。此时，该进程是新会话的唯一进程。该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID该进程没有控制终端。如果调用setsid之前该进程有一个控制终端，那么这种联系也被切断。如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID是重新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。




系统守护进程：syslogd、login、crond、at等。
网络守护进程：sendmail、httpd、xinetd、等。
独立启动的守护进程：httpd、named、xinetd等。
被动守护进程（由xinetd启动）：telnet、finger、ktalk等。

#### 同步、异步、阻塞、非阻塞


#### 线程与进程的不同

进程：系统进行资源分配和调度的基本单位。

线程：线程是进程的一个实体,是CPU调度和分派的基本单位。自己的资源：栈（参数、返回地址等）、PC（程序计数器）、TLS（线程本地存储，存独有的数据）

一个程序至少有一个进程，一个进程至少有一个线程。

多线程：对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。不利于资源的管理和保护

多进程：进程有独立的地址空间，多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些

#### vecotr<T&>可以吗


#### GET和POST

GET和POST是HTTP协议中的两种发送请求的方法。

HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。

HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。

GET产生一个TCP数据包；POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。



#### 类与结构体

类成员默认访问权限为私有(private)，结构体成员默认访问权限为公共(public)，其他地方完全一样。

#### 指针和引用的区别
指针也是一个对象，存的数据是地址，占内存。函数传参时，函数中是拷贝变量，地址指向的变量与原本相同。

引用是一个别名，不可以为空，创建时必须初始化。

sizeof（引用）得到的是对应变量的大小，而sizeof（指针）得到的是指针本身的大小。

有没有可能引用同名？

#### 指针常量和常量指针 

指针常量：所存储的地址不可变

常量指针：不能用过该指针改变所指向的对象

#### MySQL ACID

事务（Transaction）是访问和更新数据库的程序执行单元。

原子性（Atomicity，或称不可分割性）：原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。

一致性（Consistency）：数据库总是从一个一致性的状态转换到另外一个一致性状态，不会部分数据状态改变了部分状态没有改变。

隔离性（Isolation）：事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

持久性（Durability）：持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

#### MySQL 索引分类

主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引

单值索引：一个索引只包含单个列，一个表可以有多个单列索引：CREATE INDEX idx_customer_name ON customer(customer_name)

唯一索引：索引列的值必须唯一，但允许有空值：CREATE UNIQUE INDEX idx_customer_no ON customer(customer_no)， 主键自动建立唯一索引

复合索引：即一个索引包含多个列，在数据库操作期间，复合索引比单值索引所需要的开销更小(对于相同的多个列建索引)，当表的行数远大于索引列的数目时可以使用复合索引

#### 进程间通信
管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。


==========================

B树 B+树 VAL的对比

linux系统运行缓慢，什么命令查看

栈为什么比堆快

https握手过程

i++是否保证线程安全： 什么是线程安全

悲观锁和乐观锁，并发情况下，非要在这两个中选择一个的话，选哪个

mysql中的锁

排序算法的稳定性和复杂度

TCP可靠性和拥塞控制

time wait的作用

DNS的流程

怎么判断父子进程

可重复读解决了幻读？

-rwx------分别是啥？分别对应：文件的所有者、文件的组以及所有其他用户。

C++进程怎么创建

进程、线程和协程

string是如何存储数据的，具体过程？为什么会扩容2倍或1.5倍？
    以前的编译器是用写时复制（COW）技术，每当字符串发生复制构造或赋值时进行浅拷贝，只复制指针并增加一个引用计数，只有对其中一个字符串进行修改时才会执行真正的复制。既然用到了引用计数，那么就要考虑在多线程环境下的线程安全问题，而且string会把operator[]和at()都认定为修改“语义”，即使我们只是访问字符串也会触发COW，这就导致string的COW实现存在诸多弊端；
    现在编译器大多采用SSO（Small String Optimization）短字符串优化，当字符串长度小于15字节时直接存放在栈中，大于15字节时，栈中存放指针，指针指向堆中的完整字符串。这样的好处是，当字符串较短时，直接将其数据存在栈中，而不用去堆中动态申请空间，避免了申请堆空间的开销；
    在g++环境下，string的扩容机制跟vector一样是两倍扩容，最初分配的capacity是15字节；
    如果扩容倍率太低，继续插入字符的话会出现频繁扩容的现象，效率降低；如果倍率太高，又会造成空间浪费，所以我想2倍或1.5倍是一个折中的考虑，兼顾了效率与空间利用率；
